# Типы указателей в `git`

В распределённой системе контроля версий `git` каждый мало-мальски значимый тип данных имеет имеет свой 
уникальный отпечаток — контрольную сумму SHA-1 длиной в 40 символов шестнадцатеричной системы счисления 
(от `0` до `9` и от `A` до `F`). По нему можно обращаться к какому-то определённому объекту, например, к 
коммиту или ветке. Но работать только с ними было бы не совсем удобно, поэтому в системах контроля версий 
создали именованые указатели; в `git` для обычного пользователя они в основном представляются указателями 
на все существующие в проекте ветки, указателем на указатель на текущую ветку (`HEAD`) и на статические 
указатели (теги).

Каждый коммит имеет в себе информацию о всех его зафиксированных изменениях и о предыдущем коммите (если 
таковой имеется). Если рассматривать более подробно, то файл коммита является очередным промежуточным звеном 
человеко-машинного интерфейса: в нём хранятся метаданные формального коммита и указатель на так называемый 
`tree`-объект (не путать с ветвями!), хранящий в себе другие указатели, на этот раз — на `blob`-объекты, в 
которых уже и находятся запакованные данные и метаданные. `blob` расшифровывется как "Binary Large OBject", 
то есть, дословно, "Большой бинарный объект" — элементарная единица данных в `git`.

Выглядит это для трёх файлов в одном коммите примерно так:
```
                     /-> blob1a (file 1a: metadata, data)
                    /
commit1 -> treeobj1 ---> blob1b (file 1b: metadata, data)
                    \
                     \-> blob1c (file 1c: metadata, data)
```

Напомним: как уже было сказано, для каждого неабстрактного объекта в `git` вычисляется его контрольная сумма, 
являющаяся, фактически, уникальным отпечатком на этот объект.

P. S.: В реальном мире вероятность совпадения хэшей стремится к нулю, но 
[здесь](https://stackoverflow.com/questions/9392365/how-would-git-handle-a-sha-1-collision-on-a-blob) 
есть демонстрация теоретической ошибки при коллизии двух контрольных сумм в `git`.


## Коммиты и ветки

Чуть более подробно про коммиты. Каждый из них имеет метаинформацию — автора коммита, автор изменения (который 
редко отличается от автора коммита, правда), дату создания, описание, электронную подпись коммита и так далее — 
и пару указателей: на объект типа "дерево" (которое, как было сказано ранее, хранит в себе указатели на сжатые 
фактические изменения) и на предыдущий коммит:

```
    commit4 ("Relaunch" by Tsiolkovsky at 27.02.2020 13:42)  -------> treeobj4
       |
       V
    commit3 ("New poem!" by Derzhavin G. at 27.02.2020 13:42)  -----> treeobj3
       |
       V
    commit2 ("Launch test" by Tsiolkovsky at 27.02.2020 13:42)  ----> treeobj2
       |
       V
    commit1 ("Init commit" by Tsiolkovsky at 27.02.2020 13:42)  ----> treeobj1
```

А ветвь же, в свою очередь, является указателем на последний коммит в такой вот цепочке. Технически файл ветки 
в `git` является всего лишь ссылкой на конечный коммит, связанный с данной формальной ветвью: внутри такого 
файла имеется просто хэш-сумма SHA-1 нужного коммита.

При инициализации пустого репозитория никакие ветки не создаются. При клонировании репозитория по умолчанию 
копируются и все ветки, существовавшие в родительском репозитории.

#### `HEAD`

Указатель `HEAD` сам по себе почти всегда является лишь символической ссылкой на ветку, с которой сейчас 
производится работа; гораздо реже, в специфических случаях, он используется в качестве самостоятельной 
временной ветви. Находится он по пути `./.git/HEAD`.

При инициализации пустого репозитория `HEAD` указывает на потенциальную ветку названием из настройки 
"`init.defaultBranch`", по умолчанию в клиентах `git` — "`master`".

#### Теги

Тег является статическим указателем на определённый объект в базе данных `git`, чаще всего — на какой-либо
коммит. "Статический" в данном контексте означает, что автоматически он не переместится никогда, и 
передвинуть его можно только вручную. Файл тега имеет в себе только SHA1-указатель на свою цель.


## Общая визуализация по ветвям, коммитами, `HEAD`-указателем и тегам

На этом примере изображён репозиторий из шести коммитов, с двумя ветками ("master" и "test-feature"), с текущей 
рабочей веткой "master", с ветвлением без слияния в третьем коммите и с тегом "v0.1.0b" на пятом:

```
     Указатель "HEAD"
           |
           V
    Ветка "master" ---> commit6
                           |
                           V
                        commit5 <=== Тег "v0.1.0b"
                           |
                           V
                        commit4
                           |
                           |
                           |   commit3 <-- Ветка "test-feature"
                           |    /
                           V   L
                        commit2
                           |
                           V
                        commit1

```
